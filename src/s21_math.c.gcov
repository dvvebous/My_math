        -:    0:Source:s21_math.c
        -:    0:Graph:s21_math.gcno
        -:    0:Data:s21_math.gcda
        -:    0:Runs:11
        -:    1:#include "s21_math.h"
        -:    2:#include <stdio.h>
        -:    3:
        6:    4:int s21_abs (int x) {
        6:    5:    return (x < 0) ? -x : x;
        -:    6:}
        -:    7:
      763:    8:long double s21_fabs(double x) {
      763:    9:    return (x < 0) ? -x : x;
        -:   10:}
        -:   11:
        -:   12:
    #####:   13:long double s21_ceil(double x) {
        -:   14:    int count;
    #####:   15:    double y = x < 0 ? -x : x;
    #####:   16:    for (count = 0; count < y; count++) {
        -:   17:    }
    #####:   18:    return x < 0 ? -count + 1 : count;
        -:   19:}
        -:   20:
       11:   21:long double s21_exp(double x) {
       11:   22:    long double res = 0;
        -:   23:
       11:   24:    if (s21_isnan(x)) {
    #####:   25:        res = NAN_NUM;
       11:   26:    } else if (s21_is_pos_inf(x)) {
    #####:   27:        res = POSITIVE_INF_NUM;
       11:   28:    } else if (s21_is_neg_inf(x)) {
        1:   29:        res = 0.0;
        -:   30:    } else {
       10:   31:        long double q = 1;
       10:   32:        double x1 = s21_fabs(x);
        -:   33:       
      238:   34:       for (int i = 1; s21_fabs(q) > EPS_NUM && s21_fabs(res) < POSITIVE_INF_NUM; i++) {
      228:   35:            res += q;
      228:   36:            q *= x1 / i;
        -:   37:       }
        -:   38:
       10:   39:       if (x < 0) 
        2:   40:           res = 1 / res;
        -:   41:    } 
        -:   42:
       11:   43:    return res;
        -:   44:}
        -:   45:
        6:   46:long double s21_floor(double x) {
       10:   47:    return (x == (long long int)x) ? x :
        6:   48:    (x > 0) ? (long double)(((long long int)x)) :
       2*:   49:    (x < 0) ? (long double)((long long int)x) - 1 : 0;
        -:   50:}
        -:   51:
       18:   52:long double s21_fmod(double x, double y)
        -:   53:{
       18:   54:  int n = x / y;
       18:   55:  double res = (double)x - n * (double)y;
       18:   56:  return res;
        -:   57:}
        -:   58:
        6:   59:long double s21_cos(double x) {
        6:   60:    long double res = 0;
        -:   61:
       12:   62:    if (!s21_isnan(x) && !s21_is_pos_inf(x) && !s21_is_neg_inf(x)) {
        6:   63:        long double q = 1;
        -:   64:
        6:   65:        if (s21_fabs(x) > 2 * S21_PI) 
        1:   66:            x = x - 2 * S21_PI * ((int)(x / (2 * S21_PI)));
        -:   67:
       67:   68:        for (int i = 1; s21_fabs(q) > EPS_NUM; i++) {
       61:   69:            res += q;
       61:   70:            q *= (-1) * (x * x) / ((2 * i) * (2 * i - 1));
        -:   71:        }
        -:   72:    } else {
    #####:   73:        res = NAN_NUM;
        -:   74:    }
        -:   75:
        6:   76:    return res;
        -:   77:}
        -:   78:
        -:   79:
        6:   80:long double s21_sin(double x)
        -:   81:{
        6:   82:    x = s21_fmod(x, 2 * S21_PI);
        6:   83:    long double result = 0;
        6:   84:    long double expression = x;
        6:   85:    int i = 1;
     1200:   86:    while (i < 200)
        -:   87:    {
     1194:   88:        result += expression;
     1194:   89:        expression = expression * (-1) * (x*x) / ((2*i+1) * (2*i));
     1194:   90:        i++;
        -:   91:    
        -:   92:}
        6:   93:    printf("%d\n", i);
        6:   94:	return result;
        -:   95:}
        -:   96:
        -:   97:
       17:   98:int s21_is_pos_inf(double x) {
       17:   99:    return x == POSITIVE_INF_NUM ? 1 : 0;
        -:  100:}
        -:  101:
       17:  102:int s21_is_neg_inf(double x) {
       17:  103:    return x == NEGATIVE_INF_NUM ? 1 : 0;
        -:  104:}
        -:  105:
       26:  106:int s21_isnan(double x) {
       26:  107:    return x == x ? 0 : 1;
        -:  108:}
        -:  109:
        -:  110:
        7:  111:int s21_findPower(double *x) {
        7:  112:    int n = 0;
       30:  113:    while (*x >= 2) {
       23:  114:        *x /= 2; 
       23:  115:        n++;
        -:  116:    }
        7:  117:    return n;
        -:  118:}
        -:  119:
        -:  120:
       11:  121:long double s21_log(double x) {
       11:  122:    long double res = 0;
       11:  123:    if (x < 0 || s21_isnan(x)) {
        2:  124:        res = NAN_NUM;
        9:  125:    } else if (x == 0) {
        2:  126:        res = NEGATIVE_INF_NUM;
        7:  127:    } else if (x == POSITIVE_INF_NUM) {
    #####:  128:        res = POSITIVE_INF_NUM;
        -:  129:    } else {
        7:  130:        long double log2 = 0.693147180559945309;
        7:  131:        int n = s21_findPower(&x);
        7:  132:        double x1 = x - 1;
        7:  133:        long double q = x1;
      209:  134:        for (int i = 1; s21_fabs(q) > EPS_NUM; i++) {
      202:  135:            res += q;
      202:  136:            q *= (-1) * x1 * i / (i + 1);
        -:  137:        }
        7:  138:        res += n * log2;
        -:  139:    }
        -:  140:
       11:  141:    return res;
        -:  142:}
        -:  143:
        5:  144:long double s21_pow(double base, double y) {  
        5:  145:    long double result = 0;
       5*:  146:    if (y == 0) result = 1.0L;
        5:  147:    else if (y > 0) result = s21_exp(y * s21_log(base));
        -:  148:    else
    #####:  149:        result = 1 / (s21_exp(-y * s21_log(base)));
        5:  150:    return result;
        -:  151:}
        -:  152:
        6:  153:long double s21_sqrt(double x) {
        6:  154:  long double result = 0;
        6:  155:  if (x < 0) {
        1:  156:    result = NAN_NUM;
        -:  157:  } else {
        5:  158:    result = s21_pow(x, 0.5);
        -:  159:  }
        6:  160:  return result;
        -:  161:}
